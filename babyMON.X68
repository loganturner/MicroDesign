*-----------------------------------------------------------
* Operating system : babyMON
* Written by       : Logan Turner
* Date             : March 2014
* Description      : monitor program for a 68k-based microcomputer
*-----------------------------------------------------------


****************************************************************
* Assembly Constants:	(Note the offsets to account for no A0)
*
DUART   	EQU	    $100000     loaded in A0 when needed, regs are offsets
MR1A   	    EQU   	1	Mode Register1
MR2A  	    EQU   	1	points here after MR1A is set
SRA    	    EQU   	3   Status Register (read)
CSRA   	    EQU   	3   Clock Select Register
CRA   	    EQU   	5	Command Register
TBA		    EQU   	7   Transfer Holding Register
RBA		    EQU   	7	Receive Holding Register
ACR		    EQU	  	9	Auxiliary control register
RxRDY		EQU		0	Recieve ready bit position
TxRDY		EQU		2	Transmit ready bit position
BAUD		EQU	  	$CC   baud rate value = 19,200 baud
*
CR          EQU     $0D     Carriage Return
LF          EQU     $0A     Line Feed
ESC         EQU     $1B     Escape

****************************************************************
* Main Program
*
STACK       EQU     $80800	; MUST BE A VALID RAM LOCATION


START   	ORG     $000000
        	DC.L    STACK
        	DC.L    MAIN

        	ORG     $000100        
MAIN    	JSR     INIT_DUART
            BRA     MENU

****************************************************************
* Menu
*
MENU        EQU     *
* Set default option
* Clear screen
* Draw banner
* Draw logo and options
* Draw carat
* Wait for character
* If ENTER, jump to option
* If arrow, change option
            MOVE.L  #00,D2              D2 represents which option is selected
MENU1       BSR     CLRSCREEN
            BSR     PSTRING
            LEA     MENUBANNER(PC),A4   Draw menu
            BSR     PSTRING             Get char
            LEA     MENUSCREEN(PC),A4
            BSR     PSTRING
            LEA     OP1CARAT(PC),A4
            MOVE.L  #00,(A5)+
            CMP     D2,D3               Option 1 selected?
            BEQ     MENU2
            LEA     OP2CARAT(PC),A4
            CMP     (A5)+,D2            Option 2 selected?
            BEQ     MENU2
            LEA     OP3CARAT(PC),A4
            CMP     (A5)+,D2            Option 3 selected?
            BRA     MENU2
            LEA     OP4CARAT(PC),A4     Option 4 must be selected
MENU2       BSR     PSTRING
            BSR     GCHAR
            BRA     MENU

****************************************************************
* Modify Registers
*
MODREG
            BRA     MENU

****************************************************************
* Modify Memory
*
MODMEM
            BRA     MENU

****************************************************************
* Load S-Record
*
LDSREC
            BRA     MENU

****************************************************************
* Initialize DUART
*
INITDSIM    EQU     *
	        MOVE.B	#$00,D1
	        MOVE.B	#12,D0
	        TRAP		#15
	        RTS

INITDHAR    EQU     *
            LEA	  	    DUART,A0		A0 points to base DUART address

; Software reset:
      	    MOVE.B	    #$30,CRA(A0)	Reset TxA
		    MOVE.B	    #$20,CRA(A0)	Reset RxA
		    MOVE.B	    #$10,CRA(A0)	Reset MRA pointer

; Initialization:
            MOVE.B  	#$80,ACR(A0)	selects baud rate set 2
            MOVE.B  	#BAUD,CSRA(A0)  	set 19.2k baud Rx/Tx
      	    MOVE.B  	#$13,MR1A(A0)   	8-bits, no parity, 1 stop bit

; This is the most important register to set in the 68681 DUART.
; 07 sets: Normal mode, CTS and RTS disabled, stop bit length = 1
; For testing load $#47 to enable auto-echo
      	    MOVE.B	#$07,MR2A(A0)	

      	    MOVE.B	#$05,CRA(A0)	enable Tx and Rx
      	    RTS
      	    
****************************************************************
* I/O Subroutines

* Input a single character from port A (polled mode) into D0

GCHARHAR    EQU         *
	        MOVE.L      D1,-(SP)
	        MOVE.L      A1,-(SP)
            LEA         DUART,A0
Input_poll  MOVE.B      SRA(A0),D1
            BTST        #RxRDY,D1
            BEQ         Input_poll
            MOVE.B      RBA(A0),D0
            MOVE.L      (SP)+,A0
            MOVE.L      (SP)+,D1
            BSR         PCHAR       Echo Input
	        RTS

GCHARSIM    EQU         *
	        MOVE.L	D1, -(SP)	
	        MOVE.L	#05, D0
	        TRAP		#15		
	        MOVE.B	D1, D0
	        MOVE.L	(SP)+,D1
	        BSR         PCHAR       Echo Input
	        RTS

* Transmit a single character in D0 from Port A (polled mode)

PCHARHAR    MOVE.L      D1,-(SP)
            LEA         DUART,A0
Output_poll MOVE.B      SRA(A0),D1
            BTST        #TxRDY,D1
            BEQ         Output_poll
            MOVE.B      D0,TBA(A0)
            MOVE.L      (SP)+,D1
            RTS
	
PCHARSIM    EQU         *
	        MOVE.L	D0, -(SP)	; Task
	        MOVE.L	D1, -(SP)	;Char to display
	        MOVE.B	D0, D1	
	        MOVE.L	#06, D0	
	        TRAP		#15		
	        MOVE.L	(SP)+,D1	
	        MOVE.L	(SP)+,D0
	        RTS

* Display the string pointed at by A4

PSTRING     EQU         *
            MOVE.L      D0,-(A7)
PS1         MOVE.B      (A4)+,D0
            BEQ.S       PS2
            BSR         PCHAR
            BRA         PS1
PS2         MOVE.L      (A7)+,D0
            RTS

* Move cursor to start of newline

NEWLINE     EQU         *
            MOVEM.L     A4,-(A7)
            LEA         CRLF(PC),A4
            BSR         PSTRING
            MOVEM.L     (A7)+,A4
            RTS

* Print string with newline

HEADING     BSR         NEWLINE
            BSR         PSTRING
            BRA         NEWLINE

* Get line of input from user

GETLINE     EQU         *
            MOVEM.L     A4,-(A7)
            LEA         PROMPT(PC),A4
            BSR         PSTRING         Print prompt character
            MOVEM.L     (A7)+,A4
GETL1       BSR         GCHAR
            BRA         GETL1

* Get a single numeric character between 1 and 4 from user

GETNUM      EQU         *
            MOVEM.L     A4,-(A7)
            LEA         NUMPROMPT(PC),A4
            BSR         PSTRING         Print prompt character
            MOVEM.L     (A7)+,A4
GETNUM      BSR         GCHAR
            CMP.B       #$31,D0
            BLT         GETNUM1
            CMP.B       #$34,D0
            BGT         GETNUM1
            BSR         NEWLINE
            RTS

* Get a navigational character (ESC, ENTER, arrow key) from the user

GETNAV      EQU         *
            BSR         GCHAR
            CMP.B       #ESC,D0
            BEQ         GETNAV1
            CMP.B       #CR,D0
            BEQ         GETNAV1
            BRA         GETNAV
GETNAV1     RTS

* Clear the screen

CLRSCHAR    EQU         *
            LEA         CLRSCNESC(PC),A4
            BSR         PSTRING
            RTS

CLRSCSIM    EQU         *
            MOVE.L	D0, -(SP)
	        MOVE.L	D1, -(SP)
	        MOVE.L	#11, D0
	        MOVE.W  #$FF00,D1
	        TRAP		#15		
	        MOVE.L	(SP)+,D1	
	        MOVE.L	(SP)+,D0
	        RTS

****************************************************************
* Strings and Constants in ROM
*
CRLF        DC.B    CR,LF,0
CLRSCNESC   DC.B    ESC,'[2J'
PROMPT      DC.B    '> ',0
NUMPROMPT   DC.B    '#> ',0
MENUTEXT    DC.B    'Enter the number of one of the following options:',CR,LF,'1. View or modify a register',CR,LF,'2. View or modify a memory location',CR,LF,'3. Upload an S-record',CR,LF,'4. Jump to a memory location',0,0
OPNOTIMP1   DC.B    '(Option 1 not yet implemented)',0,0
OPNOTIMP2   DC.B    '(Option 2 not yet implemented)',0,0
OPNOTIMP3   DC.B    '(Option 3 not yet implemented)',0,0
OPNOTIMP4   DC.B    '(Option 4 not yet implemented)',0,0
MENUBANNER  DC.B    '                                   MAIN MENU',CR,LF,0,0
REGBANNER   DC.B    '<[ESC]                             REGISTERS',CR,LF,0,0
MEMBANNER   DC.B    '<[ESC]                               MEMORY ',CR,LF,0,0
MENUSCREEN  DC.B    CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    '                  _           _           __  __  ___  _   _  ',CR,LF
            DC.B    '                 | |__   __ _| |__  _   _|  \/  |/ _ \| \ | | ',CR,LF
            DC.B    '                 | ''_ \ / _` | ''_ \| | | | |\/| | | | |  \| | ',CR,LF
            DC.B    '                 | |_) | (_| | |_) | |_| | |  | | |_| | |\  | ',CR,LF
            DC.B    '                 |_.__/ \__,_|_.__/ \__, |_|  |_|\___/|_| \_| ',CR,LF
            DC.B    '                                    |___/         68k monitor ',CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    CR,LF
            DC.B    '       Registers       Memory       Load S-Record       Jump to Program ',CR,LF,0,0
OP1CARAT    DC.B    '           ^',CR,LF,CR,LF,CR,LF,CR,LF,0,0
OP2CARAT    DC.B    '                         ^',CR,LF,CR,LF,CR,LF,CR,LF,0,0
OP3CARAT    DC.B    '                                          ^',CR,LF,CR,LF,CR,LF,CR,LF,0,0
OP4CARAT    DC.B    '                                                               ^',CR,LF,CR,LF,CR,LF,CR,LF,0,0
GCHAR       EQU     GCHARSIM
PCHAR       EQU     PCHARSIM
INIT_DUART  EQU     INITDSIM
CLRSCREEN   EQU     CLRSCSIM

            END     MAIN













*~Font name~Courier New~
*~Font size~10~
*~Tab type~1~
*~Tab size~4~
